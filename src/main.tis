//| Sciter View v0.4
//| https://github.com/MustafaHi/Sciter-View

const HTML  = $(#HTML), CSS    = $(#CSS),
      Frame = $(frame), SCRIPT = $(#SCRIPT);

function Render() {
    Frame.frame.loadHtml(
        String.$(<html><body>{HTML.value}</body><style>{CSS.value}</style><script type='text/tiscript'>{SCRIPT.value}</script></html>),
        self.url()
    );
} Render();

self.on( 'change', 'plaintext', ()=>{debounce(Render, 1000)()} );

function debounce(func, wait, immediate = false) {
    return function(arguments..) {
        var context = this, args = arguments;
        var later = function() {
            if (!immediate) func.apply(context, args);
        };
        self.timer(wait, later);
        if (immediate) func.apply(context, args);
    };
}

class Editor : Element {

    event ~keypress(evt) {
        if (evt.shiftKey) for(var key of this.WrapKeys) 
        if (evt.keyCode == key.code) return this.Wrap(key.v);
    }
    onKey(evt) {
        if (evt.type != Event.KEY_DOWN) return;
                
        if (evt.shortcutKey)
            switch(evt.keyCode) {
                case 221: return this.Tab(true);  // ]
                    break;
                case 219: return this.Tab(false); // [
                    break;
                                                  // ENTER
                case  13: return this.newLine(evt.shiftKey ? "top" : "bottom"); 
                    break;
            }
        if (evt.keyCode == 13) this.post(:: this.newLine("keep"));
    }

    const WrapKeys = [
        { code: 123, v: ['{','}'] }, // { 123
        { code:  60, v: ['<','>'] }, // <  60
        { code:  40, v: ['(',')'] }, // (  40
    ];

    function Wrap(v) {
        var Start = this.plaintext.selectionStart,
            End   = this.plaintext.selectionEnd,
            Text  = this.plaintext.selectionText;
            // caret = this.selection.start,
            // anchor= this.selection.end;

        var S = Start[1] < End[1] ? Start : End,
            E = Start[1] > End[1] ? Start : End;

        this.execCommand("edit:insert-text", v[0] + Text + v[1]);
        this.plaintext.selectRange(S[0], S[1], E[0], S[0] == E[0] ? E[1]+1 : E[1]);
        
        return true;
        // function doit(transact) {
        //     var t = this[S[0]];
        //     transact.text(t, t.text.splice(S[1], 0, v[0]));
        //     t = this[E[0]];
        //     if (E[0] == S[0]) E[1]++;
        //     transact.text(t, t.text.splice(E[1], 0, v[1]));
        //     this.selection.select(caret, anchor);
        // }
        // this.transact(doit, "wrap text");
    }

    function Tab(add) {
        var Start = this.plaintext.selectionStart,
            End   = this.plaintext.selectionEnd;
            
        var S = Start[0] < End[0] ? Start : End,
            E = Start[0] > End[0] ? Start : End;

        this.transact((transact) => {
            for(var i =  S[0]; i <= E[0]; ++i) {
                var t =  this[i];
                if (add) transact.text(t, '\t' + t.text);
                else     transact.text(t, t.text.replace(/^\t/, ""));
            }
            S = Start, E = End;
            this.selection.select([bookmark: this[S[0]].nodes()[0], add ? S[1] : S[1] - 2, true],
                                  [bookmark: this[E[0]].nodes()[0], add ? E[1] : E[1] - 2, true]);
            return true;
        });
        return true;
    }

    function newLine(at) {
        function repeat(string, times) {
            if (times == 0) return '';
            let add = string;
            while (times != 1) { string += add; --times; }
            return string;
        }

        //| check if current line has tabs and/or end with > or {
        //| indent the new line accordingly

        if (at == "keep") //| (enter)
        {
            var S    = this.plaintext.selectionStart,
                tabs = this.plaintext[S[0]-1].match(/^\t|\>$|\{$/g)?.length || 0;
                       this.execCommand("edit:insert-text", repeat("\t", tabs));
            
            if        (this.plaintext[S[0]].slice(-1) == "}") {
                       this.execCommand("edit:insert-break");
                       this.plaintext.selectRange(0, 0, S[0], 999);
            }
        }
        else if (at == "top") //| (ctrl+shift+enter)
        {
            var S    = this.plaintext.selectionStart,
                tabs = this.plaintext[S[0]].match(/^\t/g)?.length || 0;
                       this.execCommand("navigate:line-start");
                       this.execCommand("edit:insert-text", repeat("\t", tabs) + "\r\n");
                       this.plaintext.selectRange(0, 0, S[0], 999);
        }
        else if (at == "bottom") //| (ctrl+enter)
        {
            var S    = this.plaintext.selectionStart,
                tabs = this.plaintext[S[0]].match(/^\t|\>$|\{$/g)?.length || 0;
                       this.execCommand("navigate:line-end");
                       this.execCommand("edit:insert-text", "\r\n" + repeat("\t", tabs));
        }
        return true;
    }
}